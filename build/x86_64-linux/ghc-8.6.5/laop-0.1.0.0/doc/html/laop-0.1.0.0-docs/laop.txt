-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An inductive matrix definition library Ã  la LAoP
--   
--   Please see the README on GitHub at
--   <a>https://github.com/bolt12/laop#readme</a>
@package laop
@version 0.1.0.0


-- | <b>LAoP</b> is a library for algebraic (inductive) construction and
--   manipulation of matrices in Haskell. See <a>my Msc Thesis</a> for the
--   motivation behind the library, the underlying theory, and
--   implementation details.
--   
--   This module provides the <a>Natural</a> data type. The semantic
--   associated with this data type is that it's meant to be a restricted
--   <a>Int</a> value.
module Utils

-- | Wrapper around <a>Int</a>s that have a restrictive semantic
--   associated. A value of type <tt><a>Natural</a> n m</tt> can only be
--   instanciated with some <a>Int</a> <tt>i</tt> that's <tt>n &lt;= i
--   &lt;= m</tt>.
data Natural (start :: Nat) (end :: Nat)

-- | Natural constructor function. Throws a runtime error if the <a>Int</a>
--   value is greater than the corresponding <tt>m</tt> or lower than
--   <tt>n</tt> in the <tt><a>Natural</a> n m</tt> type.
nat :: forall n m. (KnownNat n, KnownNat m) => Int -> Natural n m

-- | Auxiliary function that promotes binary <a>Int</a> functions to
--   <a>Natural</a> binary functions.
coerceNat :: (Int -> Int -> Int) -> Natural a a' -> Natural b b' -> Natural c c'

-- | Auxiliary function that promotes ternary (binary) <a>Int</a> functions
--   to <a>Natural</a> functions.
coerceNat2 :: ((Int, Int) -> Int -> Int) -> (Natural a a', Natural b b') -> Natural c c' -> Natural d d'

-- | Auxiliary function that promotes ternary (binary) <a>Int</a> functions
--   to <a>Natural</a> functions.
coerceNat3 :: (Int -> Int -> a) -> Natural b b' -> Natural c c' -> a


-- | The LAoP discipline generalises relations and functions treating them
--   as Boolean matrices and in turn consider these as arrows.
--   
--   <b>LAoP</b> is a library for algebraic (inductive) construction and
--   manipulation of matrices in Haskell. See <a>my Msc Thesis</a> for the
--   motivation behind the library, the underlying theory, and
--   implementation details.
--   
--   This module offers a newtype wrapper around <a>Matrix</a> that uses
--   arbitrary types instead of canonical data types for the matrices
--   dimensions.
--   
--   <b>NOTE</b>: If the types in the dimensions are custom they must need
--   to implement a <tt>Generic</tt> instance.
module Matrix.Type
newtype Matrix e (cols :: Type) (rows :: Type)
M :: Matrix e (Normalize cols) (Normalize rows) -> Matrix e

-- | Zero type alias
type Zero = Void

-- | One type alias
type One = ()

-- | Empty matrix constructor
empty :: Matrix e Zero Zero

-- | Unit matrix constructor
one :: e -> Matrix e One One

-- | Matrix <tt>Junc</tt> constructor
junc :: Normalize (Either a b) ~ Either (Normalize a) (Normalize b) => Matrix e a rows -> Matrix e b rows -> Matrix e (Either a b) rows

-- | Matrix <tt>Split</tt> constructor
split :: Normalize (Either a b) ~ Either (Normalize a) (Normalize b) => Matrix e cols a -> Matrix e cols b -> Matrix e cols (Either a b)

-- | Type family that computes of a given type dimension from a given
--   natural
--   
--   Thanks to Li-Yao Xia this type family is super fast.
type family FromNat (n :: Nat) :: Type

-- | Type family that computes the cardinality of a given type dimension.
--   
--   It can also count the cardinality of custom types that implement the
--   <a>Generic</a> instance.
type family Count (d :: Type) :: Nat

-- | Type family that normalizes the representation of a given data
--   structure
type family Normalize (d :: Type) :: Type

-- | Type class for defining the <tt>fromList</tt> conversion function.
--   
--   Given that it is not possible to branch on types at the term level
--   type classes are needed bery much like an inductive definition but on
--   types.
class FromLists e cols rows

-- | Build a matrix out of a list of list of elements. Throws a runtime
--   error if the dimensions do not match.
fromLists :: FromLists e (Normalize cols) (Normalize rows) => [[e]] -> Matrix e cols rows

-- | Converts a matrix to a list of lists of elements.
toLists :: Matrix e cols rows -> [[e]]

-- | Converts a matrix to a list of elements.
toList :: Matrix e cols rows -> [e]

-- | Matrix builder function. Constructs a matrix provided with a
--   construction function.
matrixBuilder :: (FromLists e (Normalize cols) (Normalize rows), KnownNat (Count (Normalize cols)), KnownNat (Count (Normalize rows))) => ((Int, Int) -> e) -> Matrix e cols rows

-- | Constructs a row vector matrix
row :: FromLists e (Normalize cols) () => [e] -> Matrix e cols One

-- | Constructs a column vector matrix
col :: FromLists e () (Normalize rows) => [e] -> Matrix e One rows

-- | The zero matrix. A matrix wholly filled with zeros.
zeros :: (Num e, FromLists e (Normalize cols) (Normalize rows), KnownNat (Count (Normalize cols)), KnownNat (Count (Normalize rows))) => Matrix e cols rows

-- | The ones matrix. A matrix wholly filled with ones.
--   
--   Also known as T (Top) matrix.
ones :: (Num e, FromLists e (Normalize cols) (Normalize rows), KnownNat (Count (Normalize cols)), KnownNat (Count (Normalize rows))) => Matrix e cols rows

-- | The T (Top) row vector matrix.
bang :: forall e cols. (Num e, Enum e, FromLists e (Normalize cols) (), KnownNat (Count (Normalize cols))) => Matrix e cols One

-- | The constant matrix constructor. A matrix wholly filled with a given
--   value.
constant :: (Num e, FromLists e (Normalize cols) (Normalize rows), KnownNat (Count (Normalize cols)), KnownNat (Count (Normalize rows))) => e -> Matrix e cols rows

-- | Functor instance equivalent function
fmapM :: (Bounded a, Bounded b, Enum a, Enum b, Eq b, Num e, Ord e, KnownNat (Count (Normalize a)), KnownNat (Count (Normalize b)), FromLists e (Normalize b) (Normalize a)) => (a -> b) -> Matrix e c a -> Matrix e c b

-- | Applicative instance equivalent <tt>unit</tt> function,
unitM :: Num e => Matrix e () ()

-- | Applicative instance equivalent <tt>unit</tt> function,
multM :: (KnownNat (Count (Normalize a)), KnownNat (Count (Normalize b)), KnownNat (Count (Normalize (a, b))), Num e, FromLists e (Normalize (a, b)) (Normalize a), FromLists e (Normalize (a, b)) (Normalize b), Normalize (a, b) ~ Normalize (Normalize a, Normalize b)) => Matrix e c a -> Matrix e c b -> Matrix e c (a, b)

-- | Selective functors <tt>select</tt> operator equivalent inspired by the
--   ArrowMonad solution presented in the paper.
selectM :: (Num e, FromLists e (Normalize b) (Normalize b), KnownNat (Count (Normalize b)), Normalize (Either a b) ~ Either (Normalize a) (Normalize b)) => Matrix e cols (Either a b) -> Matrix e a b -> Matrix e cols b

-- | Monad instance equivalent <a>return</a> function,
returnM :: forall e a. (Num e, Enum e, Enum a, FromLists e () (Normalize a), KnownNat (Count a)) => a -> Matrix e One a

-- | Monad instance equivalent '(&gt;&gt;=)' function,
bindM :: Num e => Matrix e a b -> Matrix e b c -> Matrix e a c

-- | Obtain the number of columns.
--   
--   NOTE: The <a>KnownNat</a> constaint is needed in order to obtain the
--   dimensions in constant time.
--   
--   TODO: A <a>columns</a> function that does not need the <a>KnownNat</a>
--   constraint in exchange for performance.
columns :: KnownNat (Count (Normalize cols)) => Matrix e cols rows -> Int

-- | Obtain the number of rows.
--   
--   NOTE: The <a>KnownNat</a> constaint is needed in order to obtain the
--   dimensions in constant time.
--   
--   TODO: A <a>rows</a> function that does not need the <a>KnownNat</a>
--   constraint in exchange for performance.
rows :: KnownNat (Count (Normalize rows)) => Matrix e cols rows -> Int

-- | Matrix transposition.
tr :: Matrix e cols rows -> Matrix e rows cols

-- | McCarthy's Conditional expresses probabilistic choice.
cond :: (Normalize (Normalize a) ~ Normalize a, KnownNat (Count (Normalize a)), FromLists e () (Normalize a), FromLists e (Normalize a) (), FromLists e (Normalize a) (Normalize a), Bounded a, Enum a, Num e, Ord e) => (a -> Bool) -> Matrix e a b -> Matrix e a b -> Matrix e a b

-- | Matrix "abiding" followin the 'Junc'-'Split' abide law.
--   
--   Law:
--   
--   <pre>
--   <tt>Junc</tt> (<tt>Split</tt> a c) (<tt>Split</tt> b d) == <tt>Split</tt> (<tt>Junc</tt> a b) (<tt>Junc</tt> c d)
--   </pre>
abideJS :: Matrix e cols rows -> Matrix e cols rows

-- | Matrix "abiding" followin the 'Split'-'Junc' abide law.
--   
--   Law:
--   
--   <pre>
--   <tt>Split</tt> (<tt>Junc</tt> a b) (<tt>Junc</tt> c d) == <tt>Junc</tt> (<tt>Split</tt> a c) (<tt>Split</tt> b d)
--   </pre>
abideSJ :: Matrix e cols rows -> Matrix e cols rows

-- | Matrix <tt>Split</tt> constructor
(===) :: Normalize (Either a b) ~ Either (Normalize a) (Normalize b) => Matrix e cols a -> Matrix e cols b -> Matrix e cols (Either a b)
infixl 2 ===

-- | Biproduct first component projection
p1 :: (Num e, KnownNat (Count (Normalize n)), KnownNat (Count (Normalize m)), FromLists e (Normalize n) (Normalize m), FromLists e (Normalize m) (Normalize m), Normalize (Either m n) ~ Either (Normalize m) (Normalize n)) => Matrix e (Either m n) m

-- | Biproduct second component projection
p2 :: (Num e, KnownNat (Count (Normalize n)), KnownNat (Count (Normalize m)), FromLists e (Normalize m) (Normalize n), FromLists e (Normalize n) (Normalize n), Normalize (Either m n) ~ Either (Normalize m) (Normalize n)) => Matrix e (Either m n) n

-- | Matrix <tt>Junc</tt> constructor
(|||) :: Normalize (Either a b) ~ Either (Normalize a) (Normalize b) => Matrix e a rows -> Matrix e b rows -> Matrix e (Either a b) rows
infixl 3 |||

-- | Biproduct first component injection
i1 :: (Num e, KnownNat (Count (Normalize n)), KnownNat (Count (Normalize m)), FromLists e (Normalize n) (Normalize m), FromLists e (Normalize m) (Normalize m), Normalize (Either m n) ~ Either (Normalize m) (Normalize n)) => Matrix e m (Either m n)

-- | Biproduct second component injection
i2 :: (Num e, KnownNat (Count (Normalize n)), KnownNat (Count (Normalize m)), FromLists e (Normalize m) (Normalize n), FromLists e (Normalize n) (Normalize n), Normalize (Either m n) ~ Either (Normalize m) (Normalize n)) => Matrix e n (Either m n)

-- | Matrix coproduct functor also known as matrix direct sum.
(-|-) :: (Num e, KnownNat (Count (Normalize j)), KnownNat (Count (Normalize k)), FromLists e (Normalize k) (Normalize k), FromLists e (Normalize j) (Normalize k), FromLists e (Normalize k) (Normalize j), FromLists e (Normalize j) (Normalize j), Normalize (Either n m) ~ Either (Normalize n) (Normalize m), Normalize (Either k j) ~ Either (Normalize k) (Normalize j)) => Matrix e n k -> Matrix e m j -> Matrix e (Either n m) (Either k j)
infixl 5 -|-

-- | Matrix product functor also known as kronecker product
(><) :: forall e m p n q. (Num e, KnownNat (Count (Normalize m)), KnownNat (Count (Normalize n)), KnownNat (Count (Normalize p)), KnownNat (Count (Normalize q)), KnownNat (Count (Normalize (m, n))), KnownNat (Count (Normalize (p, q))), FromLists e (Normalize (m, n)) (Normalize m), FromLists e (Normalize (m, n)) (Normalize n), FromLists e (Normalize (p, q)) (Normalize p), FromLists e (Normalize (p, q)) (Normalize q), Normalize (m, n) ~ Normalize (Normalize m, Normalize n), Normalize (p, q) ~ Normalize (Normalize p, Normalize q)) => Matrix e m p -> Matrix e n q -> Matrix e (m, n) (p, q)
infixl 4 ><

-- | Khatri Rao product first component projection matrix.
kp1 :: forall e m k. (Num e, KnownNat (Count (Normalize m)), KnownNat (Count (Normalize k)), KnownNat (Count (Normalize (m, k))), FromLists e (Normalize (m, k)) (Normalize m), Normalize (m, k) ~ Normalize (Normalize m, Normalize k)) => Matrix e (m, k) m

-- | Khatri Rao product second component projection matrix.
kp2 :: forall e m k. (Num e, KnownNat (Count (Normalize k)), KnownNat (Count (Normalize m)), KnownNat (Count (Normalize (m, k))), FromLists e (Normalize (m, k)) (Normalize k), Normalize (m, k) ~ Normalize (Normalize m, Normalize k)) => Matrix e (m, k) k

-- | Khatri Rao Matrix product also known as matrix pairing.
--   
--   NOTE: That this is not a true categorical product, see for instance:
--   
--   <pre>
--                  | kp1 <a>comp</a> khatri a b == a 
--   khatri a b ==&gt; |
--                  | kp2 <a>comp</a> khatri a b == b
--   </pre>
--   
--   <b>Emphasis</b> on the implication symbol.
khatri :: forall e cols a b. (Num e, KnownNat (Count (Normalize a)), KnownNat (Count (Normalize b)), KnownNat (Count (Normalize (a, b))), FromLists e (Normalize (a, b)) (Normalize a), FromLists e (Normalize (a, b)) (Normalize b), Normalize (a, b) ~ Normalize (Normalize a, Normalize b)) => Matrix e cols a -> Matrix e cols b -> Matrix e cols (a, b)

-- | Identity matrix
identity :: (Num e, FromLists e (Normalize a) (Normalize a), KnownNat (Count (Normalize a))) => Matrix e a a

-- | Matrix composition. Equivalent to matrix-matrix multiplication.
--   
--   This definition takes advantage of divide-and-conquer and fusion laws
--   from LAoP.
comp :: Num e => Matrix e cr rows -> Matrix e cols cr -> Matrix e cols rows

-- | Lifts functions to matrices with arbitrary dimensions.
--   
--   NOTE: Be careful to not ask for a matrix bigger than the cardinality
--   of types <tt>a</tt> or <tt>b</tt> allows.
fromF :: (Bounded a, Bounded b, Enum a, Enum b, Eq b, Num e, Ord e, KnownNat (Count (Normalize cols)), KnownNat (Count (Normalize rows)), FromLists e (Normalize rows) (Normalize cols)) => (a -> b) -> Matrix e cols rows

-- | Lifts functions to matrices with dimensions matching <tt>a</tt> and
--   <tt>b</tt> cardinality's.
fromF' :: (Bounded a, Bounded b, Enum a, Enum b, Eq b, Num e, Ord e, KnownNat (Count (Normalize a)), KnownNat (Count (Normalize b)), FromLists e (Normalize b) (Normalize a)) => (a -> b) -> Matrix e a b

-- | Matrix pretty printer
pretty :: (KnownNat (Count (Normalize cols)), Show e) => Matrix e cols rows -> String

-- | Matrix pretty printer
prettyPrint :: (KnownNat (Count (Normalize cols)), Show e) => Matrix e cols rows -> IO ()
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (Matrix.Type.Matrix e cols rows)
instance GHC.Classes.Ord e => GHC.Classes.Ord (Matrix.Type.Matrix e cols rows)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Matrix.Type.Matrix e cols rows)
instance GHC.Num.Num e => GHC.Num.Num (Matrix.Type.Matrix e cols rows)
instance GHC.Show.Show e => GHC.Show.Show (Matrix.Type.Matrix e cols rows)
instance GHC.Num.Num e => Control.Category.Category (Matrix.Type.Matrix e)


-- | The LAoP discipline generalises relations and functions treating them
--   as Boolean matrices and in turn consider these as arrows.
--   
--   <b>LAoP</b> is a library for algebraic (inductive) construction and
--   manipulation of matrices in Haskell. See <a>my Msc Thesis</a> for the
--   motivation behind the library, the underlying theory, and
--   implementation details.
--   
--   This module offers a newtype wrapper around <a>Matrix</a> that uses
--   type level naturals instead of standard data types for the matrices
--   dimensions.
module Matrix.Nat
newtype Matrix e (cols :: Nat) (rows :: Nat)
M :: Matrix e (FromNat cols) (FromNat rows) -> Matrix e
empty :: Matrix e 0 0
one :: e -> Matrix e 1 1
junc :: FromNat cols3 ~ Either (FromNat cols1) (FromNat cols2) => Matrix e cols1 rows -> Matrix e cols2 rows -> Matrix e cols3 rows
split :: FromNat rows3 ~ Either (FromNat rows1) (FromNat rows2) => Matrix e cols rows1 -> Matrix e cols rows2 -> Matrix e cols rows3

-- | Type family that computes of a given type dimension from a given
--   natural
--   
--   Thanks to Li-Yao Xia this type family is super fast.
type family FromNat (n :: Nat) :: Type

-- | Type family that computes the cardinality of a given type dimension.
--   
--   It can also count the cardinality of custom types that implement the
--   <a>Generic</a> instance.
type family Count (d :: Type) :: Nat

-- | Type family that normalizes the representation of a given data
--   structure
type family Normalize (d :: Type) :: Type

-- | Type class for defining the <tt>fromList</tt> conversion function.
--   
--   Given that it is not possible to branch on types at the term level
--   type classes are needed bery much like an inductive definition but on
--   types.
class FromLists e cols rows
fromLists :: FromLists e (FromNat cols) (FromNat rows) => [[e]] -> Matrix e cols rows
toLists :: Matrix e cols rows -> [[e]]
toList :: Matrix e cols rows -> [e]
matrixBuilder :: (FromLists e (FromNat cols) (FromNat rows), KnownNat (Count (FromNat cols)), KnownNat (Count (FromNat rows))) => ((Int, Int) -> e) -> Matrix e cols rows
row :: FromLists e (FromNat cols) () => [e] -> Matrix e cols 1
col :: FromLists e () (FromNat rows) => [e] -> Matrix e 1 rows
zeros :: (Num e, FromLists e (FromNat cols) (FromNat rows), KnownNat (Count (FromNat cols)), KnownNat (Count (FromNat rows))) => Matrix e cols rows
ones :: (Num e, FromLists e (FromNat cols) (FromNat rows), KnownNat (Count (FromNat cols)), KnownNat (Count (FromNat rows))) => Matrix e cols rows
bang :: forall e cols. (Num e, Enum e, FromLists e (FromNat cols) (), KnownNat (Count (FromNat cols))) => Matrix e cols 1
constant :: (Num e, FromLists e (FromNat cols) (FromNat rows), KnownNat (Count (FromNat cols)), KnownNat (Count (FromNat rows))) => e -> Matrix e cols rows
columns :: KnownNat (Count (FromNat cols)) => Matrix e cols rows -> Int
rows :: KnownNat (Count (FromNat rows)) => Matrix e cols rows -> Int
tr :: Matrix e cols rows -> Matrix e rows cols
select :: (Num e, FromLists e (FromNat rows1) (FromNat rows1), KnownNat (Count (FromNat rows1)), FromNat rows2 ~ FromNat rows1, FromNat cols1 ~ FromNat cols2, FromNat rows3 ~ Either (FromNat cols3) (FromNat rows1)) => Matrix e cols1 rows3 -> Matrix e cols3 rows1 -> Matrix e cols2 rows2
cond :: (FromNat (Count (FromNat cols)) ~ FromNat cols, KnownNat (Count (FromNat cols)), FromLists e () (FromNat cols), FromLists e (FromNat cols) (), FromLists e (FromNat cols) (FromNat cols), Bounded a, Enum a, Num e, Ord e) => (a -> Bool) -> Matrix e cols rows -> Matrix e cols rows -> Matrix e cols rows
abideJS :: Matrix e cols rows -> Matrix e cols rows
abideSJ :: Matrix e cols rows -> Matrix e cols rows
(===) :: FromNat rows3 ~ Either (FromNat rows1) (FromNat rows2) => Matrix e cols rows1 -> Matrix e cols rows2 -> Matrix e cols rows3
infixl 2 ===
p1 :: (Num e, KnownNat (Count (FromNat n)), KnownNat (Count (FromNat m)), FromLists e (FromNat n) (FromNat m), FromLists e (FromNat m) (FromNat m), FromNat (m + n) ~ Either (FromNat m) (FromNat n)) => Matrix e (m + n) m
p2 :: (Num e, KnownNat (Count (FromNat n)), KnownNat (Count (FromNat m)), FromLists e (FromNat m) (FromNat n), FromLists e (FromNat n) (FromNat n), FromNat (m + n) ~ Either (FromNat m) (FromNat n)) => Matrix e (m + n) n
(|||) :: FromNat cols3 ~ Either (FromNat cols1) (FromNat cols2) => Matrix e cols1 rows -> Matrix e cols2 rows -> Matrix e cols3 rows
infixl 3 |||
i1 :: (Num e, KnownNat (Count (FromNat n)), KnownNat (Count (FromNat rows)), FromLists e (FromNat n) (FromNat rows), FromLists e (FromNat rows) (FromNat rows), FromNat (rows + n) ~ Either (FromNat rows) (FromNat n)) => Matrix e rows (rows + n)
i2 :: (Num e, KnownNat (Count (FromNat rows)), KnownNat (Count (FromNat m)), FromLists e (FromNat m) (FromNat rows), FromLists e (FromNat rows) (FromNat rows), FromNat (m + rows) ~ Either (FromNat m) (FromNat rows)) => Matrix e rows (m + rows)
(-|-) :: (Num e, KnownNat (Count (FromNat j)), KnownNat (Count (FromNat k)), FromLists e (FromNat k) (FromNat k), FromLists e (FromNat j) (FromNat k), FromLists e (FromNat k) (FromNat j), FromLists e (FromNat j) (FromNat j), FromNat (n + m) ~ Either (FromNat n) (FromNat m), FromNat (k + j) ~ Either (FromNat k) (FromNat j)) => Matrix e n k -> Matrix e m j -> Matrix e (n + m) (k + j)
infixl 5 -|-
(><) :: forall e m p n q. (Num e, KnownNat (Count (FromNat m)), KnownNat (Count (FromNat n)), KnownNat (Count (FromNat p)), KnownNat (Count (FromNat q)), KnownNat (Count (FromNat (m * n))), KnownNat (Count (FromNat (p * q))), FromLists e (FromNat (m * n)) (FromNat m), FromLists e (FromNat (m * n)) (FromNat n), FromLists e (FromNat (p * q)) (FromNat p), FromLists e (FromNat (p * q)) (FromNat q), FromNat (m * n) ~ FromNat (Count (FromNat m) * Count (FromNat n)), FromNat (p * q) ~ FromNat (Count (FromNat p) * Count (FromNat q))) => Matrix e m p -> Matrix e n q -> Matrix e (m * n) (p * q)
infixl 4 ><
kp1 :: forall e m k. (Num e, KnownNat (Count (FromNat m)), KnownNat (Count (FromNat k)), KnownNat (Count (FromNat (m * k))), FromLists e (FromNat (m * k)) (FromNat m), FromNat (m * k) ~ FromNat (Count (FromNat m) * Count (FromNat k))) => Matrix e (m * k) m
kp2 :: forall e m k. (Num e, KnownNat (Count (FromNat k)), FromLists e (FromNat (m * k)) (FromNat k), KnownNat (Count (FromNat m)), KnownNat (Count (FromNat (m * k))), FromNat (m * k) ~ FromNat (Count (FromNat m) * Count (FromNat k))) => Matrix e (m * k) k
khatri :: forall e cols a b. (Num e, KnownNat (Count (FromNat a)), KnownNat (Count (FromNat b)), KnownNat (Count (FromNat (a * b))), FromLists e (FromNat (a * b)) (FromNat a), FromLists e (FromNat (a * b)) (FromNat b), FromNat (a * b) ~ FromNat (Count (FromNat a) * Count (FromNat b))) => Matrix e cols a -> Matrix e cols b -> Matrix e cols (a * b)
identity :: (Num e, FromLists e (FromNat cols) (FromNat cols), KnownNat (Count (FromNat cols))) => Matrix e cols cols
comp :: Num e => Matrix e cr rows -> Matrix e cols cr -> Matrix e cols rows
fromF :: (Bounded a, Bounded b, Enum a, Enum b, Eq b, Num e, Ord e, KnownNat (Count (FromNat cols)), KnownNat (Count (FromNat rows)), FromLists e (FromNat rows) (FromNat cols)) => (a -> b) -> Matrix e cols rows
fromF' :: (Bounded a, Bounded b, Enum a, Enum b, Eq b, Num e, Ord e, KnownNat (Count (Normalize a)), KnownNat (Count (Normalize b)), FromLists e (Normalize b) (Normalize a)) => (a -> b) -> Matrix e (Count a) (Count b)
pretty :: (KnownNat (Count (FromNat cols)), Show e) => Matrix e cols rows -> String
prettyPrint :: (KnownNat (Count (FromNat cols)), Show e) => Matrix e cols rows -> IO ()
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (Matrix.Nat.Matrix e cols rows)
instance GHC.Classes.Ord e => GHC.Classes.Ord (Matrix.Nat.Matrix e cols rows)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Matrix.Nat.Matrix e cols rows)
instance GHC.Num.Num e => GHC.Num.Num (Matrix.Nat.Matrix e cols rows)
instance GHC.Show.Show e => GHC.Show.Show (Matrix.Nat.Matrix e cols rows)
instance GHC.Num.Num e => Control.Category.Category (Matrix.Nat.Matrix e)


-- | <b>LAoP</b> is a library for algebraic (inductive) construction and
--   manipulation of matrices in Haskell. See <a>my Msc Thesis</a> for the
--   motivation behind the library, the underlying theory, and
--   implementation details.
--   
--   This module exports a type synonym <a>Dist</a> that represents a
--   stochastic distribution matrix and several distribution construction
--   functions.
module Dist

-- | Type synonym for column vector matrices. This represents a probability
--   distribution.
newtype Dist a
D :: Matrix Prob () a -> Dist a

-- | Type synonym for probability value
type Prob = Double

-- | Functor instance
fmapD :: (Bounded a, Bounded b, Enum a, Enum b, Eq b, KnownNat (Count (Normalize a)), KnownNat (Count (Normalize b)), FromLists Prob (Normalize b) (Normalize a)) => (a -> b) -> Dist a -> Dist b

-- | Applicative/Monoidal instance <tt>unit</tt> function
unitD :: Dist ()

-- | Applicative/Monoidal instance <tt>mult</tt> function
multD :: (KnownNat (Count (Normalize a)), KnownNat (Count (Normalize b)), KnownNat (Count (Normalize (a, b))), FromLists Prob (Normalize (a, b)) (Normalize a), FromLists Prob (Normalize (a, b)) (Normalize b), Normalize (a, b) ~ Normalize (Normalize a, Normalize b)) => Dist a -> Dist b -> Dist (a, b)

-- | Selective instance function
selectD :: (Normalize (Either a b) ~ Either (Normalize a) (Normalize b), FromLists Prob (Normalize b) (Normalize b), KnownNat (Count (Normalize b))) => Dist (Either a b) -> Matrix Prob a b -> Dist b

-- | Monad instance <a>return</a> function
returnD :: forall a. (Enum a, FromLists Prob () (Normalize a), KnownNat (Count a)) => a -> Dist a

-- | Monad instance '(&gt;&gt;=)' function
bindD :: Dist a -> Matrix Prob a b -> Dist b

-- | Constructs a Bernoulli distribution
choose :: FromLists Prob () (Normalize a) => Prob -> Dist a

-- | Creates a distribution given a shape function
shape :: FromLists Prob () (Normalize a) => (Prob -> Prob) -> [a] -> Dist a

-- | Constructs a Linear distribution
linear :: FromLists Prob () (Normalize a) => [a] -> Dist a

-- | Constructs an Uniform distribution
uniform :: FromLists Prob () (Normalize a) => [a] -> Dist a

-- | Constructs an Negative Exponential distribution
negExp :: FromLists Prob () (Normalize a) => [a] -> Dist a

-- | Constructs an Normal distribution
normal :: FromLists Prob () (Normalize a) => [a] -> Dist a

-- | Transforms a <a>Dist</a> into a list of pairs.
toValues :: forall a. (Enum a, KnownNat (Count a), FromLists Prob () (Normalize a)) => Dist a -> [(a, Prob)]

-- | Pretty a distribution
prettyDist :: forall a. (Show a, Enum a, KnownNat (Count a), FromLists Prob () (Normalize a)) => Dist a -> String

-- | Pretty Print a distribution
prettyPrintDist :: forall a. (Show a, Enum a, KnownNat (Count a), FromLists Prob () (Normalize a)) => Dist a -> IO ()
